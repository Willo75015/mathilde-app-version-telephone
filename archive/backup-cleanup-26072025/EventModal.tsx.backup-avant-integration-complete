import React, { useState, useEffect, useCallback, useMemo } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { 
  X, Edit, Calendar, MapPin, DollarSign, Phone, 
  User, Clock, FileText, Users, CheckCircle, 
  XCircle, AlertCircle, MessageSquare, Trash2,
  Plus
} from 'lucide-react'
import { Event, Client } from '@/types'
import Button from '@/components/ui/Button'
import PhoneInput from '@/components/ui/PhoneInput'
import FloristCard from '@/components/ui/FloristCard'  // üÜï Import du composant r√©utilisable
import FloristAssignmentComplete from './FloristAssignmentComplete'  // üÜï Composant complet d'assignation
import { useEventSync, useModalEventSync } from '@/hooks/useEventSync'
import { useApp, useFlorists } from '@/contexts/AppContext'

// Types pour les fleuristes
interface Florist {
  id: string
  name: string
  role: string
  status: 'available' | 'unavailable' | 'busy'
  avatar?: string
}

interface FloristAssignment {
  floristId: string
  status: 'pending' | 'confirmed' | 'refused' | 'not_selected' // üÜï
  assignedAt: Date
}

interface EventModalProps {
  event: Event | null
  client?: Client
  isOpen: boolean
  onClose: () => void
  onEdit?: (event: Event) => void
  initialView?: 'details' | 'assignment'
}

const EventModal: React.FC<EventModalProps> = ({
  event,
  client,
  isOpen,
  onClose,
  onEdit,
  initialView = 'details'
}) => {
  // üîß CORRECTION: Utiliser initialView seulement √† l'ouverture
  const [currentView, setCurrentView] = useState<'details' | 'assignment'>('details')
  
  // üîß CORRECTION: Ordre des hooks fixe et memoization pour √©viter warnings
  const { state, actions } = useApp()
  const { emitEventSync } = useEventSync()
  const { latestEvent } = useModalEventSync(event?.id || null, 'EventModal')
  
  // üîß R√©cup√©rer florists depuis le state directement pour √©viter double useApp
  const florists = useMemo(() => state.florists || [], [state.florists])

  // State pour les notifications
  const [showLimitReachedPopup, setShowLimitReachedPopup] = useState(false)
  const [showMaxReachedAlert, setShowMaxReachedAlert] = useState(false)
  
  // State local pour l'√©dition (clone de l'√©v√©nement)
  const [editedEvent, setEditedEvent] = useState<Event | null>(null)
  
  // Assignations bas√©es sur l'√©v√©nement r√©el
  const [assignments, setAssignments] = useState<FloristAssignment[]>([])

  // üîß CORRECTION: Fusionner tous les useEffect en un seul avec flag
  const [isInitialized, setIsInitialized] = useState(false)
  
  useEffect(() => {
    if (!isOpen) {
      // Reset quand ferm√©
      setIsInitialized(false)
      setEditedEvent(null)
      setAssignments([])
      setCurrentView('details')
      return
    }

    // √âviter les re-initialisations inutiles
    if (isInitialized) return

    console.log('üîÑ EventModal - Initialisation unique...')
    
    // 1. Initialiser la vue
    setCurrentView(initialView)
    
    // 2. Initialiser l'√©v√©nement
    const currentEvent = latestEvent || event
    if (currentEvent) {
      console.log('üîÑ EventModal - Initialisation avec donn√©es r√©centes:', {
        eventId: currentEvent.id,
        assignedFlorists: currentEvent.assignedFlorists?.length || 0,
        isLatest: !!latestEvent
      })
      setEditedEvent({ ...currentEvent })
      
      // 3. Initialiser les assignations
      if (currentEvent.assignedFlorists) {
        const newAssignments = currentEvent.assignedFlorists.map(af => ({
          floristId: af.floristId,
          status: af.status || (af.isConfirmed ? 'confirmed' : af.isRefused ? 'refused' : 'pending') as const,
          assignedAt: af.assignedAt
        }))
        setAssignments(newAssignments)
        console.log('‚úÖ EventModal - Assignations charg√©es:', newAssignments)
      } else {
        setAssignments([])
      }
    } else {
      // Mode cr√©ation - nouvel √©v√©nement
      console.log('üÜï EventModal - Mode cr√©ation nouvel √©v√©nement')
      const newEvent: Event = {
        id: `temp-${Date.now()}`,
        title: '',
        description: '',
        date: new Date(),
        time: '09:00',
        endTime: '17:00',
        location: '',
        clientId: '',
        clientPhone: '',
        budget: 0,
        status: 'draft' as any,
        flowers: [],
        floristsRequired: 2,
        assignedFlorists: [],
        createdAt: new Date(),
        updatedAt: new Date()
      }
      setEditedEvent(newEvent)
      setAssignments([])
    }
    
    setIsInitialized(true)
    console.log('‚úÖ EventModal - Initialisation termin√©e')
    
  }, [isOpen, event, latestEvent, initialView, isInitialized])

  // üîß CORRECTION: Hook pour mettre √† jour seulement les assignations quand latestEvent change
  useEffect(() => {
    if (!isOpen || !isInitialized || !latestEvent) return
    
    // Si l'√©v√©nement a √©t√© mis √† jour par synchronisation
    if (latestEvent.id === editedEvent?.id && latestEvent.assignedFlorists) {
      console.log('üîÑ EventModal - Mise √† jour assignations depuis sync:', latestEvent.id)
      
      const updatedAssignments = latestEvent.assignedFlorists.map(af => ({
        floristId: af.floristId,
        status: af.status || (af.isConfirmed ? 'confirmed' : af.isRefused ? 'refused' : 'pending') as const,
        assignedAt: af.assignedAt
      }))
      
      setAssignments(updatedAssignments)
      setEditedEvent({ ...latestEvent })
    }
  }, [latestEvent, isOpen, isInitialized, editedEvent?.id])

  // üÜï R√©cup√©rer tous les fleuristes depuis les √©v√©nements existants
  const getAllFloristsFromEvents = useCallback(() => {
    const floristsMap = new Map()
    
    // R√©cup√©rer tous les √©v√©nements
    const allEvents = state.events || []
    
    // Parcourir tous les √©v√©nements pour extraire les fleuristes
    allEvents.forEach(event => {
      event.assignedFlorists?.forEach(af => {
        if (!floristsMap.has(af.floristId)) {
          floristsMap.set(af.floristId, {
            id: af.floristId,
            name: af.floristName,
            role: af.floristRole || 'Fleuriste', 
            status: 'available' // Par d√©faut disponible, sera calcul√© par getFloristStatus
          })
        }
      })
    })
    
    // Ajouter les fleuristes de base s'ils ne sont pas dans les √©v√©nements
    const baseFlorists = [
      { id: '1', name: 'Marie Dubois', role: 'Assistant Fleuriste', status: 'available' },
      { id: '2', name: 'Paul Renault', role: 'Responsable D√©coration', status: 'available' },
      { id: '3', name: 'Jean Moreau', role: 'Sp√©cialiste Mariage', status: 'available' },
      { id: '4', name: 'Sophie Laurent', role: 'Senior Fleuriste', status: 'available' },
      { id: '5', name: 'Claire Petit', role: 'Junior Fleuriste', status: 'busy' },
      { id: '6', name: 'Marc Durand', role: 'Cr√©ateur Bouquets', status: 'unavailable' }
    ]
    
    baseFlorists.forEach(florist => {
      if (!floristsMap.has(florist.id)) {
        floristsMap.set(florist.id, florist)
      }
    })
    
    return Array.from(floristsMap.values())
  }, [state.events])

  // üîß CORRECTION: Memoizer les fleuristes pour √©viter les recalculs
  const availableFlorists = useMemo(() => {
    return florists?.length > 0 ? florists : getAllFloristsFromEvents()
  }, [florists, getAllFloristsFromEvents])

  // üîß CORRECTION: Utiliser des hooks sans recalculs inutiles
  const { updateEventWithTeamCheck } = useApp()
  const { syncFloristAssignments } = useEventSync()
  
  // R√©f√©rence pour g√©rer le scroll
  const scrollContainerRef = React.useRef<HTMLDivElement>(null)

  // üîß CORRECTION: Memoizer les calculs pour √©viter les re-renders
  const floristStats = useMemo(() => {
    if (!editedEvent || !assignments) return { required: 0, confirmed: 0, percentage: 0 }
    
    const requiredFlorists = editedEvent.floristsRequired || 4
    const confirmedCount = assignments.filter(a => a.status === 'confirmed').length
    const progressPercentage = Math.min((confirmedCount / requiredFlorists) * 100, 100)
    
    return {
      required: requiredFlorists,
      confirmed: confirmedCount,
      percentage: progressPercentage
    }
  }, [editedEvent, assignments])

  // üîß CORRECTION: Memoizer les fleuristes disponibles
  const assignedFloristIds = useMemo(() => 
    assignments.map(a => a.floristId), [assignments]
  )
  
  const unassignedFlorists = useMemo(() => 
    availableFlorists.filter(f => !assignedFloristIds.includes(f.id)), 
    [availableFlorists, assignedFloristIds]
  )

  // Fonction helper pour synchroniser imm√©diatement les assignations
  const syncAssignmentsImmediately = useCallback((newAssignments: FloristAssignment[]) => {
    if (!editedEvent) return
    
    const updatedAssignedFlorists = newAssignments.map(assignment => ({
      floristId: assignment.floristId,
      floristName: availableFlorists.find(f => f.id === assignment.floristId)?.name || '',
      isConfirmed: assignment.status === 'confirmed',
      isRefused: assignment.status === 'refused',
      status: assignment.status,
      assignedAt: assignment.assignedAt
    }))
    
    console.log('‚ö° EventModal - AVANT updateEventWithTeamCheck:', {
      eventId: editedEvent.id,
      assignedFlorists: updatedAssignedFlorists,
      confirmedCount: updatedAssignedFlorists.filter(f => f.status === 'confirmed').length
    })
    
    // üÜï Utiliser la nouvelle fonction avec v√©rification d'√©quipe compl√®te
    updateEventWithTeamCheck(editedEvent.id, { 
      assignedFlorists: updatedAssignedFlorists 
    })
    
    // Synchroniser avec les autres modals imm√©diatement
    syncFloristAssignments(editedEvent.id, updatedAssignedFlorists, 'EventModal')
    
    console.log('‚ö° EventModal - Synchronisation avec v√©rification √©quipe:', {
      eventId: editedEvent.id,
      assignmentsCount: newAssignments.length
    })
  }, [editedEvent, availableFlorists, updateEventWithTeamCheck, syncFloristAssignments])

  const getFloristsByStatus = useCallback((status: FloristAssignment['status']) => {
    return assignments
      .filter(a => a.status === status)
      .map(a => availableFlorists.find(f => f.id === a.floristId)!)
      .filter(Boolean)
  }, [assignments, availableFlorists])

  const handleAddFlorist = useCallback((florist: Florist) => {
    // Sauvegarder la position de scroll avant l'ajout
    const scrollPosition = scrollContainerRef.current?.scrollTop || 0
    
    const newAssignments = [...assignments, {
      floristId: florist.id,
      status: 'pending' as const, // Ajouter en "pending" d'abord
      assignedAt: new Date()
    }]
    
    setAssignments(newAssignments)
    
    // Synchroniser imm√©diatement avec les autres modals
    syncAssignmentsImmediately(newAssignments)
    
    // Restaurer la position de scroll apr√®s le re-render
    setTimeout(() => {
      if (scrollContainerRef.current) {
        scrollContainerRef.current.scrollTop = scrollPosition
      }
    }, 0)
  }, [assignments, syncAssignmentsImmediately])

  const handleUpdateFloristStatus = useCallback((floristId: string, newStatus: FloristAssignment['status']) => {
    // V√©rifier la limite seulement si on essaie de confirmer
    if (newStatus === 'confirmed') {
      const currentConfirmed = assignments.filter(a => a.status === 'confirmed').length
      
      if (currentConfirmed >= floristStats.required) {
        setShowMaxReachedAlert(true)
        setTimeout(() => setShowMaxReachedAlert(false), 3000)
        return
      }
    }
    
    // Sauvegarder la position de scroll
    const scrollPosition = scrollContainerRef.current?.scrollTop || 0
    
    const newAssignments = assignments.map(a => 
      a.floristId === floristId ? { ...a, status: newStatus } : a
    )
    
    console.log('üîß AVANT handleUpdateFloristStatus:', {
      floristId,
      oldStatus: assignments.find(a => a.floristId === floristId)?.status,
      newStatus,
      newConfirmedCount: newAssignments.filter(a => a.status === 'confirmed').length,
      requiredFlorists: floristStats.required
    })
    
    setAssignments(newAssignments)
    
    // üÜï V√âRIFICATION AUTO-PASSAGE APR√àS CHANGEMENT DE STATUT
    const confirmedCount = newAssignments.filter(a => a.status === 'confirmed').length
    if (confirmedCount >= floristStats.required) {
      console.log('üéâ √âQUIPE COMPL√àTE D√âTECT√âE ! Auto-passage des "pending" ‚Üí "not_selected"')
      
      // Passer automatiquement tous les "pending" en "not_selected"
      const finalAssignments = newAssignments.map(a => {
        if (a.status === 'pending') {
          console.log(`üìù Auto-passage: ${availableFlorists.find(f => f.id === a.floristId)?.name} ‚Üí "not_selected"`)
          return { ...a, status: 'not_selected' as const }
        }
        return a
      })
      
      setAssignments(finalAssignments)
      syncAssignmentsImmediately(finalAssignments)
    } else {
      // Synchronisation normale
      syncAssignmentsImmediately(newAssignments)
    }
    
    // V√©rifier si on vient d'atteindre la limite de confirm√©s
    if (newStatus === 'confirmed') {
      const newConfirmedCount = assignments.filter(a => a.status === 'confirmed').length + 1
      if (newConfirmedCount === floristStats.required) {
        setTimeout(() => {
          setShowLimitReachedPopup(true)
        }, 100)
      }
    }
    
    // Restaurer la position
    setTimeout(() => {
      if (scrollContainerRef.current) {
        scrollContainerRef.current.scrollTop = scrollPosition
      }
    }, 0)
  }, [assignments, floristStats.required, availableFlorists, syncAssignmentsImmediately])

  const handleRemoveFlorist = useCallback((floristId: string) => {
    // Sauvegarder la position de scroll
    const scrollPosition = scrollContainerRef.current?.scrollTop || 0
    
    const newAssignments = assignments.filter(a => a.floristId !== floristId)
    setAssignments(newAssignments)
    
    // Synchroniser imm√©diatement avec les autres modals
    syncAssignmentsImmediately(newAssignments)
    
    // Restaurer la position
    setTimeout(() => {
      if (scrollContainerRef.current) {
        scrollContainerRef.current.scrollTop = scrollPosition
      }
    }, 0)
  }, [assignments, syncAssignmentsImmediately])

  // Fonctions pour mettre √† jour l'√©v√©nement en cours d'√©dition
  const updateEventField = useCallback((field: keyof Event, value: any) => {
    if (editedEvent) {
      setEditedEvent(prev => prev ? { ...prev, [field]: value } : null)
    }
  }, [editedEvent])

  // üîß CORRECTION: Sauvegarder les modifications avec validation
  const handleSave = useCallback(() => {
    if (!editedEvent || !onEdit) {
      console.error('‚ùå Pas d\'√©v√©nement √† sauvegarder ou pas de fonction onEdit')
      return
    }
    
    // üõ°Ô∏è VALIDATION DES CHAMPS OBLIGATOIRES
    const errors: string[] = []
    
    if (!editedEvent.title || editedEvent.title.trim() === '') {
      errors.push('Le titre est requis')
    }
    
    if (!editedEvent.date) {
      errors.push('La date est requise')
    }
    
    if (!editedEvent.location || editedEvent.location.trim() === '') {
      errors.push('Le lieu est requis')
    }
    
    if (!editedEvent.clientId || editedEvent.clientId.trim() === '') {
      errors.push('Le client est requis')
    }
    
    if (editedEvent.budget <= 0) {
      errors.push('Le budget doit √™tre positif')
    }
    
    if (errors.length > 0) {
      console.error('üî• D√âTAIL DES ERREURS:', errors)
      alert('Erreurs de validation:\n' + errors.join('\n'))
      return
    }
    
    // üîß CORRECTION : Logique de cr√©ation vs modification robuste
    const isCreating = !event || !event.id || event.id.startsWith('temp-') || event.id.startsWith('event-temp-')
    
    // Synchroniser les assignations avec l'√©v√©nement
    const updatedEvent = {
      ...editedEvent,
      // G√©n√©rer un nouvel ID si c'est une cr√©ation
      id: isCreating ? `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` : editedEvent.id,
      assignedFlorists: assignments.map(assignment => ({
        floristId: assignment.floristId,
        floristName: availableFlorists.find(f => f.id === assignment.floristId)?.name || '',
        isConfirmed: assignment.status === 'confirmed',
        isRefused: assignment.status === 'refused',
        status: assignment.status,
        assignedAt: assignment.assignedAt
      })),
      floristsRequired: floristStats.required,
      // Mettre √† jour le statut de l'√©v√©nement selon les assignations
      status: floristStats.confirmed >= floristStats.required ? 'confirmed' : editedEvent.status,
      // Mettre √† jour les timestamps
      createdAt: isCreating ? new Date() : editedEvent.createdAt,
      updatedAt: new Date()
    }
    
    console.log(`üíæ EventModal - ${isCreating ? 'Cr√©ation' : 'Modification'} √©v√©nement:`, {
      eventId: updatedEvent.id,
      title: updatedEvent.title,
      date: updatedEvent.date,
      clientId: updatedEvent.clientId,
      budget: updatedEvent.budget,
      location: updatedEvent.location,
      floristsRequired: floristStats.required,
      assignedFlorists: updatedEvent.assignedFlorists,
      confirmedCount: floristStats.confirmed,
      newStatus: updatedEvent.status
    })
    
    try {
      // √âmettre la synchronisation AVANT l'appel onEdit
      emitEventSync(updatedEvent, 'EventModal')
      
      // Appel onEdit pour maintenir la compatibilit√© (g√®re cr√©ation ET modification)
      onEdit(updatedEvent)
      
      console.log('‚úÖ √âv√©nement sauvegard√© avec succ√®s')
      onClose()
    } catch (error) {
      console.error('‚ùå Erreur lors de la sauvegarde:', error)
      alert('Erreur lors de la sauvegarde: ' + (error as Error).message)
    }
  }, [editedEvent, onEdit, assignments, availableFlorists, floristStats, event, emitEventSync, onClose])

  // Annuler les modifications
  const handleCancel = useCallback(() => {
    if (event) {
      setEditedEvent({ ...event }) // Reset aux valeurs originales
    }
    onClose()
  }, [event, onClose])

  // üîß CORRECTION: Toujours retourner un JSX m√™me si ferm√© pour √©viter warnings hooks
  return (
    <AnimatePresence>
      {isOpen && editedEvent && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="event-modal-container"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.9, opacity: 0 }}
            className="event-modal-content"
            onClick={(e) => e.stopPropagation()}
          >
            {/* Header */}
            <div className="event-modal-header flex items-center justify-between">
              <div className="flex items-center space-x-4">
                <input
                  type="text"
                  value={editedEvent.title}
                  onChange={(e) => updateEventField('title', e.target.value)}
                  className="bg-transparent border-b-2 border-primary-500 focus:outline-none focus:border-primary-600 text-2xl font-bold text-gray-900 dark:text-white"
                  placeholder={event ? "Nom de l'√©v√©nement" : "Nom du nouvel √©v√©nement"}
                />
                
                {/* Bouton Traiter Urgent */}
                <Button
                  variant="outline"
                  size="sm"
                  className="px-4 border-orange-300 text-orange-600 hover:bg-orange-50"
                >
                  ‚ö† Traiter Urgent
                </Button>
              </div>

              <div className="flex items-center space-x-2">
                {/* Boutons de navigation */}
                <Button
                  variant={currentView === 'details' ? 'primary' : 'ghost'}
                  size="sm"
                  onClick={() => setCurrentView('details')}
                >
                  üìã D√©tails
                </Button>
                
                <Button
                  variant={currentView === 'assignment' ? 'primary' : 'ghost'}
                  size="sm"
                  onClick={() => setCurrentView('assignment')}
                >
                  üë• Assignation
                </Button>

                <Button
                  variant="ghost"
                  size="sm"
                  onClick={onClose}
                >
                  <X className="w-4 h-4" />
                </Button>
              </div>
            </div>

            {/* Contenu principal */}
            <div className="flex-1 overflow-hidden">
              {currentView === 'details' && (
                <div className="p-6 overflow-y-auto">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* Informations de base */}
                    <div className="space-y-4">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                          Description
                        </label>
                        <textarea
                          value={editedEvent.description}
                          onChange={(e) => updateEventField('description', e.target.value)}
                          className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                          rows={3}
                          placeholder="Description de l'√©v√©nement..."
                        />
                      </div>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Date
                          </label>
                          <input
                            type="date"
                            value={editedEvent.date ? editedEvent.date.toISOString().split('T')[0] : ''}
                            onChange={(e) => updateEventField('date', new Date(e.target.value))}
                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                          />
                        </div>

                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Heure
                          </label>
                          <input
                            type="time"
                            value={editedEvent.time}
                            onChange={(e) => updateEventField('time', e.target.value)}
                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                          />
                        </div>
                      </div>

                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                          Lieu
                        </label>
                        <input
                          type="text"
                          value={editedEvent.location}
                          onChange={(e) => updateEventField('location', e.target.value)}
                          className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                          placeholder="Lieu de l'√©v√©nement"
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                          Budget (‚Ç¨)
                        </label>
                        <input
                          type="number"
                          value={editedEvent.budget}
                          onChange={(e) => updateEventField('budget', Number(e.target.value))}
                          className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                          min="0"
                        />
                      </div>
                    </div>

                    {/* Informations client */}
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Informations Client</h3>
                      
                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                          Client ID
                        </label>
                        <input
                          type="text"
                          value={editedEvent.clientId}
                          onChange={(e) => updateEventField('clientId', e.target.value)}
                          className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                          placeholder="ID du client"
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                          T√©l√©phone
                        </label>
                        <PhoneInput
                          value={editedEvent.clientPhone || ''}
                          onChange={(phone) => updateEventField('clientPhone', phone)}
                          placeholder="T√©l√©phone du client"
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                          Fleuristes requis
                        </label>
                        <input
                          type="number"
                          value={editedEvent.floristsRequired || 2}
                          onChange={(e) => updateEventField('floristsRequired', Number(e.target.value))}
                          className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                          min="1"
                          max="10"
                        />
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {currentView === 'assignment' && (
                <div className="event-modal-body">
                  <FloristAssignmentComplete
                    editedEvent={editedEvent}
                    allEvents={allEvents}
                    onUpdateFloristStatus={handleUpdateFloristStatus}
                    onRemoveFlorist={handleRemoveFlorist}
                    onAddFlorist={handleAddFlorist}
                  />
                </div>
              )}
            </div>

            {/* Footer */}
            <div className="flex justify-between items-center p-6 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800">
              <div className="text-sm text-gray-500">
                {floristStats.confirmed}/{floristStats.required} fleuriste confirm√©
              </div>

              <div className="flex space-x-3">
                <Button variant="outline" onClick={handleCancel}>
                  Annuler
                </Button>
                <Button onClick={handleSave}>
                  ‚úÖ Valider & Synchroniser
                </Button>
              </div>
            </div>

            {/* Popups de notification */}
            <AnimatePresence>
              {showLimitReachedPopup && (
                <motion.div
                  initial={{ opacity: 0, scale: 0.9 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.9 }}
                  className="absolute top-4 right-4 bg-green-100 border border-green-300 rounded-lg p-4 shadow-lg"
                >
                  <p className="text-green-700 font-medium">
                    üéâ √âquipe compl√®te ! L'√©v√©nement peut √™tre confirm√©.
                  </p>
                </motion.div>
              )}

              {showMaxReachedAlert && (
                <motion.div
                  initial={{ opacity: 0, scale: 0.9 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.9 }}
                  className="absolute top-4 right-4 bg-orange-100 border border-orange-300 rounded-lg p-4 shadow-lg"
                >
                  <p className="text-orange-700 font-medium">
                    ‚ö†Ô∏è Maximum de fleuristes atteint
                  </p>
                </motion.div>
              )}
            </AnimatePresence>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  )
}

export default EventModal
